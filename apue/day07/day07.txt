信号
	信号是UNIX系统响应某些状况而产生的事件，进程在接受到信号时会采取响应的行动。
	信号是因为某些错误条件而产生的，比如，内存冲突，浮点溢出，或非法指令。
	信号是在软件层次上对中断的一种模拟，所以信号也叫软中断.

查看信号 kill -l
man 7 signal 

进程对信号的响应方式
	执行默认操作
	忽略信号
		对信号不采取任何操作，这两个信号不能SIGKILL SIGSTOP不能被忽略
	捕获并处理信号
		内核中断正在处理的代码，转去执行我们先前注册的信号处理程序
		SIGKILL SIGSTOP不能被处理
安装信号
	signal(信号， 信号处理程序)
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t hand);
	signal是一个带signum和hand两个参数的函数，准备捕获或忽略的信号由signum给出，接受到指定的信号时，将要调用的函数由hand给出
	hand这个参数必须有一个int参数,接受到的信号代码,返回值必须是void

	hand不仅可以是信号处理函数也可以是一下两个：
		SIG_IGN 屏蔽该信号
		SIG_DFL 接受到该信号时，采取缺省动作。
#define SIG_DFL ((__sighandler_t)0)
#define SIG_IGN ((__sighandler_t)1)
#define SIG_ERR ((__sighandler_t)-1)
typedef void __signalfn_t(int);
typedef __signalfn_t *__sighandler_t;

	当信号到来时，保存现场，转去执行信号处理程序，然后，恢复现场继续执行，实现了异步处理能力.

信号的分类
	 可靠信号
	 不可靠信号
	 实时信号
	 非实时信号

不可靠信号：
linux的信号机制主要来源于UNIX,早期UNIX系统中的信号机制简单和原始，后来在实践过程中发现了一些问题，主要问题：
	在处理信号后，就将信号的响应设置成默认的动作。在某些情况下，将导致对信号的错误处理，因此，用户不希望这样的操作，那就要每次在信号处理的末尾在调用一次signal重新注册,Linux系统信号不会被恢复。
	信号丢失

Linux支持不可靠信号，但是Linux对不可靠信号做了改进，主要是不会让信号恢复到默认动作，因此Linux的不可靠信号主要指的是信号可能丢失。

可靠信号
	随着时间的站，实践证明了有必要对信号的原始机制进行改进和扩充，所以后来出现的各种版本的UNIX分别在这方面进行了研究，力图实现"可靠信号"，由于原来的信号已经有很多应用，不好再做改动，最终只好新增加了一些信号，并在一开始就把他们定义成可靠信号，这些信号支持排队，不丢失。
	(34-64)可靠信号
	(1-31)不可靠信号

实时信号
	支持排队，是可靠信号 34 - 64

发送信号
int kill(pid_t pid, int sig);
	pid>0 将信号sig发送给进程号为pid的进程
	pid=0 信号sig将被发送给调用者进程组的每一个进程
	pid=-1 将信号发送给所有有权发送信号的进程，除了1号进程和自身
	pid<-1 将信号发送给-pid进程组的每一个进程


给自身发信号
raise(sig) <==> kill(getpid(), sig);

向进程组的每一个进程发送信号
int killpg(int pgrp, int sig)
kill(-getpgrp(), sig);

pause() 将进程置为可中断的睡眠状态，然后他会调用schedule(),使Linux进程调度器找到另一个进程来运行。pause使调度进程挂起，直到一个信号被捕获。 

延时器
int alarm(unsigned int seconds)
	等待seconds秒后发送一个SIGALRM信号给本进程，如果seconds写0，表示清除延时器

可重入函数，不可重入函数
	为了增强程序的稳定性，在信号处理函数中应使用可重入函数
	所谓可重入函数是指一个可以被多个任务调用的函数，任务在调用时不必担心数据会出错。因为进程收到信号后，就跳转到信号处理函数接着执行，如果信号处理函数中使用了不可重入函数，那么信号处理函数可能会修改原来进程中不应该被修改的数据，这样进程从信号处理函数中返回接着执行时，可能会出现预料不到的结果，不可重入函数在信号处理函数中被视为不安全的。
	满足一下条件的函数是不可重入函数：
	1.使用了静态数据结构的函数 getlogin()
	2.malloc/free
	3.实现时使用了标准I/O的函数

要向直到系统中哪些函数是可重入的 man  7 signal

