什么是操作系统？
	有效的管理计算机系统中的软硬件资源，合理的管理计算机系统的工作流程，方便用户使用的程序的集合。

操作系统的五大任务：
	文件管理
	处理器管理
	内存管理
	设备管理
	作业管理 
Linux内核模块
	进程调度
	内存管理
	虚拟文件系统VFS
	网络接口
	进程间通信

操作系统管理硬件
	防止硬件被失控的应用程序滥用
	向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备。

操作系统的三个基本抽象
	操作系统通过三个基本抽象概念来实现这两个基本功能(进程，虚拟存储器，文件), 文件是对I/o设备的抽象表示，虚拟存储器是对主存和I/O设备的抽象表示，进程是对处理器，主存和I/O设备的抽象表示。

进程
	进程是操作系统对正在运行的程序的一种抽象，一个系统可以运行多个进程，而每个进程好像都在独占使用硬件。

进程的上下文切换

虚拟存储器：
	虚拟存储器为每个进程提供一个大的，一致的，私有的地址空间
	它将内存看成是存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在主存与磁盘中来回切换数据。
	为每个进程提供一致的地址空间，简化了存储管理
	保护每个进程空间不被其他进程破坏。
	
文件：
	文件是一系列的字节序列
	它向应用程序提供了一个统一的视角来看待系统中各种各样的I/O设备。

虚拟文件系统VFS
	虚拟文件系统是linux内核提供的一种架构，为用户空间提供统一的文件操作接口，即文件系统调用，在内核内部为不同的真实文件系统提供一致的抽象接口。	
	用户通过系统调用与内核中的虚拟文件系统交互，进而操作实际的文件系统和设备。
系统编程：
	API (application programming interface)
	系统编程与应用编程：
		系统编程：在OS上利用系统调用，C库进行对系统资源访问。gcc，gdb，Apache，Memcached,MySQL
		应用编程：跟底层的API无关，用上层的库来编程，Qt，MFC...

	系统调用，对每个系统调用进行编号，在调用的时候，我们将系统调用号放入eax寄存器，int 0x80,系统调用如果要传递参数，ebx,ecx,edx,edi,esi,如果参数超过5个，用寄存器保存内存放参数的地址。


错误处理：
	在系统编程中通常通过函数返回值表示，并通过特殊的变量errno来表述。
	在errno.h头文件中声明
	extern int errno
	错误处理函数
	perror(const char *str);
	char *strerror(int errnum)

文件与I/O
	输入输出是主存与外部设备之间拷贝数据的过程
	设备 => 内存 (input)
	内存 => 设备 (output)
高级I/O
	C提供的带缓存的
低级I/O
	不带缓存的IO
文件描述符
	在标准C中访问文件用FILE指针，在系统中对文件进行的是通过一个整数。当打开或创建一个文件的时候，内核向进程返回一个文件描述符(非负).后续对文件的操作只需要通过对该文件描述符，其实内核保存着文件的相关信息，这些对用户是透明的。
	系统启动是自动帮我们打开了三个文件：
	0  输入       1  输出        2  出错
	STDIN_FILENO  STDOUT_FILENO  STDERR_FILENO
	stdin         stdout         stderr
	
文件指针和文件描述符之间可以互换
	fileno()  将文件指针转换成文件描述符号
	fdopen()  将文件描述符转换成文件指针

与文件操作相关的基本系统调用
	open
	read
	write
	close

int open(const char *pathname, int flags);
函数功能：
	打开文件
参数
	pathname 文件名，可以是相对或绝对路径
返回值：
	成功：返回文件描述符
	失败：返回-1

int open(const char *pathname, int flags, mode_t mode);
	mode：用来规定文件所有者，文件的用户组，文件的其他用户的访问权限
返回值：
	成功：返回文件描述符
	失败：返回-1
	
	flags 打开模式
		O_RDONLY 以只读的方式打开
		O_WRONLY 以只写的方式打开
		O_RDWR   以读写的方式打开
		O_CREAT  打开文件，如果不存在则创建
		O_APPEND 以追加方式打开文件
		O_EXCL   O_EXCL|O_CREAT 如果文件存在，open失败
		O_TRUNC  在open时，将文件内容清空

一旦文件打开，只要用O_RDONLY或O_RDWR标志打开，就可以用read系统调用从该文件中读取字节.
ssize_t read(int fd, void *buf, size_t count);
函数功能：
	从fd描述符所指的文件中读取最多count个数据放入buf开始的地址中，返回的是读取到buf中的字节数	
	fd:已经打开的文件描述符
	buf：内存块指针，从文件读来的数据放入这个内存地址
	count:buf的大小
返回值：
	成功：从文件复制到buf的字节数
	失败：-1

ssize_t  write(int fd, const void *buf, size_t count);
函数功能
	用write将数据写入一个文件
	fd:已经打开的文件描述符
	buf:从这块空间读取数据写入文件中
	count：要写入的字节数
返回值：成功：返回写入的字节数
		失败：-1

当read返回，放在buf中的字节的是已经从文件中拷贝到的buf的字节数，但write返回大于0，不代表数据写入文件中，只表示数据写入到内核缓存区，如果要同步写入磁盘，可以用fsync(int fd)将内核中还未写入磁盘的数据写入磁盘,也可以通过open的 O_SYNC

	






