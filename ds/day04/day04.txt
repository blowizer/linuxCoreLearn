用两个栈实现一个队列

思路：
	准备两个栈：inStack和outStack
	当入队，直接入inStack栈
	当出队，如果outStack为空
		将inStack栈中的数据全部出栈，并且入栈outStack
		然后将outStack栈的栈顶元素出栈
	如果outStack栈中的数据不为空，直接从outStack中出栈	
伪代码:
	Append(queue, node) {
		Push(inStack, node);
	}
	Retrieve(queue) {
		if ( Size(outStack) == 0 ) {
			while (Size(inStack) > 0 )
				Push(outStack, Pop(inStack));
		}
	
		return Pop(outStack);
	}

树：
	一种非线性的数据结构
	数是由n(n>=0)个节点组成的有限集合
		如果n为0，则为空树
		如果n>0，则：
			有1个特定的称之为root的节点，只有直接后继，没有直接前驱。
			除根以外的其他节点划分位m(m>=0)个互不相交的有限集合T0,T1,....Tm-1,每个集合又是一棵树，并称之为根的子树。	
	
	概念：
		度:节点拥有的子树数称为节点的度
			如果节点的度为0，称之为叶节点
			度不为0的节点称之为分支节点
		树的度定义为所有节点中的度的最大值。
		
		节点的直接后继就是该节点的孩子,该节点就称为孩子节点的双亲.
		节点的孩子的孩子的...孩子称之为该节点的子孙，相应的，该节点称为这些子孙的祖先。
		同一个双亲的孩子之间叫兄弟
		节点的层次
			根为第一层
			根的孩子为第二层
			....
			树中节点的最大的层数称为数的高度
		如果树中的节点的各子树的从左到右的次序是有序的，子树之间的顺序不能调换，这种树叫有序树，否则就叫无序树。
		森林：是由n(n>=0)棵互不相交的树组成的集合
	树的操作
		创建
		销毁
		清空
		插入
		删除
		获得
		获得根
		获得树的节点数
		获得树的度
		获得树的高度

A
	B
		E
		F
	C
	D		
		H
		I
		J




















